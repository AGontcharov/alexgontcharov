<div class="page-header projects-description">
	<h1> Personal Projects </h2>
	<h3> <a href="https://github.com/AGontcharov"> https://github.com/AGontcharov</a> </h4>
</div>

<div class ="all-projects">
	<div class="row">
			<h3> Dialog System Compiler </h3>
			<div class="project-image">
				<a href="https://github.com/AGontcharov/Dialog-System-Compiler"> <img src="/assets/img/dialogcOverview.png"> </a>
			</div>
			<div class="description-parent">
				<div class="description-container">
					<p>Dialog System Compiler (Dialogc) is an IDE compiler which takes a simplified pre-determined language and spits out an executable Java GUI code which can be run directly in the IDE or as a stand alone program. Dialogc comes with 2 compile mode: IDE Compiler and Lex/Yacc Compiler. The IDE Compiler is the in built default compiler for Dialogc which is based on a finite state machine implemented in C. On the other hand, the Lex/Yacc Compiler is based on tokens provided by the Lexixal Analyzer Genetaor and the grammar rules defined in Yacc (Yet Another Compiler-Compiler). In addition, the Lex/Yacc Compiler can be run as a stand alone program (yadc) also spitting out an executable Java GUI code. </p>

					<p>The GUI for Dialogc is fully implemented in Java, under the Swing library and is connected straight to the IDE Compiler through the Java Native Interface (JNI). Furthermore, a bash script is provided which will guide a user through the installation of the Dialog System Compiler and install in a directory of their choice. The newly compile Java GUI code also has hooks attached for action listeners which need to be provided by the user after the initial compile as a class on its own. </p>
				</div>
			</div>
	</div>

	<div class="row">
		<h3> Wildebeest 2 Player Chess AI </h3>
		<div class="project-image">
			<a href="https://github.com/AGontcharov/Wildebeest-2-Player-Chess-AI"> <img src="/assets/img/wildebeestOverview.png"> </a>
		</div>
		<div class="description-parent">
			<div class="description-container">
				<p><a href="https://en.wikipedia.org/wiki/Wildebeest_Chess">Wildebeest chess</a> is a chess variant orginaly created by R. Wayne Schmittberger where the board is 11x10 squares. The board consists of the standard chess pieces along with a couple new pieces whose moveset, after effects and rules can be found in the table in the README. In addition, there are a few special squares on the board which are detailed further down below in another table. </p>

				<p>The Wildebeest 2 Player Chess AI generates all the possible states (possible moves) of a board for a player as his next move. All the states produce adhere to the Wildebeest chess rules and are then added to a list. From this list all the states are given a score based on a heuristic function that is applied to them. A state with the highest score is chosen as the succesfor as the player's next move. The Wildebeest Chess AI by default has depth set to 2 and therefore will look into the future 2 moves ahead producing better result but at a computational cost. Scores are only applied to resulting state, therfore at depth 3 only boards three moves ahead will have a score applied to them. In addition, the Wildebeest Chess AI is also based on the <a href="http://will.thimbleby.net/algorithms/doku.php?id=minimax_search_with_alpha-beta_pruning">Minimax Search with Alpha-beta pruning. </a></p>
			</div>
		</div>
	</div>


	<div class="row">
		<h3> Artificial Neural Network </h3>
		<div class="project-image">
			<a href="https://github.com/AGontcharov/Artificial-Neural-Network"> <img src="http://futurehumanevolution.com/wp-content/uploads/Artificial-Intelligence-Neural-Network-Nodes.jpg"> </a>
		</div>
		<div class="description-parent">
			<div class="description-container">
				<p>An Artifical Neural Network implemented from scratch based on the neural structure of the human brain using Python and the Numpy library. Features (set of input) from a trainning data file are sent to the input nodes of the neural network. The neural network is then trained over a number of epochs adjusting the weights for its connection based on the actual output through forward and back propagation. Finally, after being trained the testing data is then used as input to the neural network and an output is spit back on a scale of 0 to 1. </p>
			</div>
		</div>
	</div>

	<div class="row">
		<h3> Genetic Algorithms </h3>
		<div class="project-image">
			<a href="#"> <img src="https://nnpdf.hepforge.org/images/GA.png"> </a>
		</div>
		<div class="description-parent">
			<div class="description-container">
				<p>Maecenas pharetra ac enim placerat convallis. Praesent molestie orci pretium, elementum nibh quis, lacinia libero. Duis mollis mollis dui nec molestie. Nunc pulvinar, velit ut maximus condimentum, felis lacus porta elit, eu laoreet neque enim non diam. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed ornare quam id elit rutrum scelerisque vitae vitae nunc. Nam sollicitudin vehicula egestas. In viverra est in dolor luctus ultrices. Sed id laoreet lectus. Aliquam pellentesque, mi eu dapibus convallis, purus est pharetra tortor, non rutrum felis eros vulputate diam. Sed eget arcu faucibus sem viverra fringilla sit amet ac magna. Mauris in elementum velit, in finibus nibh. Fusce tempus aliquet quam, ut volutpat quam ullamcorper congue. </p>
			</div>
		</div>
	</div>
</div>
<!-- ./all-projects -->