<!-- <div class="projects-description">
	<h1>My Personal Projects</h1>
	<a href="https://github.com/AGontcharov"> https://github.com/AGontcharov</a>
</div> -->

<div class ="all-projects">
	<div class="container">
		<div class="row">
			<div class="col-xs-12 col-lg-6 project-image">
				<img src="/assets/img/dialogcOverview2.png">
			</div>
			<div class="col-xs-12 col-lg-6 description-parent">
				<div class="description-container">
					<a href="https://github.com/AGontcharov/Dialog-System-Compiler"> <h3> Dialog System Compiler </h3></a>
					<p class="sub-heading">C, Java, JNI, Makefile, Bash, Lex/Yacc</p>

					<p>Dialog System Compiler (Dialogc) is an IDE compiler which takes a simplified pre-determined language and spits out an executable Java GUI code which can be run directly in the IDE or as a stand alone program. Dialogc comes with 2 compile mode: IDE Compiler and Lex/Yacc Compiler. The IDE Compiler is the in built default compiler for Dialogc which is based on a finite state machine implemented in C. On the other hand, the Lex/Yacc Compiler is based on tokens provided by the Lexical Analyzer Genetaor and the grammar rules defined in Yacc (Yet Another Compiler-Compiler). In addition, the Lex/Yacc Compiler can be run as a stand alone program (yadc) also spitting out an executable Java GUI code.</p>

					<p>The GUI for Dialogc is fully implemented in Java, under the Swing library and is connected straight to the IDE Compiler through the Java Native Interface (JNI). Furthermore, a bash script is provided which will guide the user through the installation of the Dialog System Compiler and install it in a directory of their choice. The newly compile Java GUI code also has hooks attached for action listeners which need to be provided by the user after the initial compile as a class on its own.</p>
				</div>
			</div>
		</div>
		<!-- /.row -->
	</div>
	<!-- /.container -->

	<div class="container">
		<div class="row">
			<div class="col-xs-12 col-lg-6 project-image">
				<img src="/assets/img/wildebeestOverview2.png">
			</div>
			<div class="col-xs-12 col-lg-6 description-parent">
				<div class="description-container">
					<a href="https://github.com/AGontcharov/Wildebeest-2-Player-Chess-AI"><h3> Wildebeest 2 Player Chess AI </h3></a>
					<p class="sub-heading">Python</p>

					<p><a href="https://en.wikipedia.org/wiki/Wildebeest_Chess">Wildebeest chess</a> is a chess variant originally created by R. Wayne Schmittberger where the board is 11x10 squares. The board consists of the standard chess pieces along with a couple new pieces whose moveset, after effects, and rules can be found in the table below. In addition, there are special squares on the board with that perform unusual actions which are also detailed further down below in another table.</p>

					<p>The Wildebeest 2 Player Chess AI generates all the possible states (moves) of a board for a player as his next move. All the states produce adhere to the Wildebeest chess rules and are then added to a list. From this list all the states are given a score based on a heuristic function that is applied to them. A state with the highest score is chosen as the successor as the player's next move. The Wildebeest Chess AI by default has depth set to 2 and therefore will look 2 moves ahead through <a href="http://will.thimbleby.net/algorithms/doku.php?id=minimax_search_with_alpha-beta_pruning">Minimax Search with Alpha-beta pruning</a> producing better result but at a computational cost. Scores are only applied to resulting state, therefore at depth 3 only boards three moves ahead will have a score applied to them.</p>
				</div>
			</div>
		</div>
		<!-- /.row -->
	</div>
	<!-- /.container -->

	<div class="container">
		<div class="row">
			<div class="col-xs-12 col-lg-6 project-image">
				<img src="/assets/img/artificialNeuralNetwork.jpg">
			</div>
			<div class="col-xs-12 col-lg-6 description-parent">
				<div class="description-container">
					<a href="https://github.com/AGontcharov/Artificial-Neural-Network"><h3> Artificial Neural Network </h3></a>
					<p class="sub-heading">Python</p>

					<p>An Artifical Neural Network implemented from scratch based on the neural structure of the human brain using Python and the Numpy library. Features (set of input) from a trainning data file are sent to the input nodes of the neural network. The neural network is then trained over a number of epochs adjusting the weights for its connections based on the actual output through forward and back propagation. Through backpropagation the neural network figures out which nodes are to blame for the error in the network and adjust the weights of the connection betwene the nodes accordingly. Finally, after being trained the testing data is then used as input to the neural network and an output is spit back on a scale of 0 to 1.</p>
				</div>
			</div>
		</div>
		<!-- /.row -->
	</div>
	<!-- /.container -->

	<div class="container">
		<div class="row">
			<div class="col-xs-12 col-lg-6 project-image">
				<img id="genetic" src="https://nnpdf.hepforge.org/images/GA.png">
			</div>
			<div class="col-xs-12 col-lg-6 description-parent">
				<div class="description-container">
					<a href="https://github.com/AGontcharov/Genetic-Algorithm"><h3> Genetic Algorithms </h3></a>
					<p class="sub-heading">C, Makefile</p>

					<p>Implementation of a genetic algorithm written in pure C that optimizes arbitrary bit strings of sizes 8. Given a random starting population of octane bit strings a fitness function which evaluates the number of set bits is applied to determine the fitness value of each bit string (individual). Two candidates are then chosen through fitness proportionate selection (roulette wheel selection) and single point crossover is performed to produce offsprings from those two candidates. This process is repeated until the children generation matches that of the parent generation. In addition, each offspring will have a 1 / bit string length chance to be selected for mutation where a random bit will be toggled. The simulation is ran until the maximum generation is reached or a solution based on the fitness function has been found i.e. if the bit strings are of length of 16 then the solution is 16.</p>
				</div>
			</div>
		</div>
		<!-- /.row -->
	</div>
	<!-- /.container -->
</div>
<!-- ./all-projects -->
